---
title: "ST537-G6-HW1"
author: "Group6"
date: "4/6/2020"
output: 
  pdf_document: 
    highlight: tango
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```
#### 3.6.1 Exercises

### 1. What geom would you use to draw a line chart? A boxplot? A histogram? An area chart?

## Line Chart
```{r cars, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) +
  geom_line()
```

## Boxplot
```{r cars, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, group = drv)) +
  geom_boxplot()
```

## Histogram
```{r cars, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ)) +
  geom_histogram()
```

## Area Chart
```{r cars, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv))

```

### 2. Run this code in your head and predict what the output will look like. Then, run the code in R and check your predictions.

## looks like this code will add each point and smoothed for hwy against  displ grouped by dy drive

```{r cars, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() + 
  geom_smooth(se = FALSE)
```

### 3. What does show.legend = FALSE do? What happens if you remove it? Why do you think I used it earlier in the chapter?

##  The show.legend = FALSE means R won't show the legend of the smooth fuction.
## If you remove it, there is only one legend based on smooth.
## Used it to show the two different options
```{r cars, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() + 
  geom_smooth(show.legend = FALSE)

ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() + 
  geom_smooth()
```

### 4. What does the se argument to geom_smooth() do?

##  The se argument to geom_smooth displays confidence interval around smooth.
```{r cars, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() + 
  geom_smooth(se = FALSE)
?geom_smooth

ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() + 
  geom_smooth()
```

### 5. Will these two graphs look different? Why/why not?

## These two graphs will look the same because the mapping is the same in geom_point and geom_smooth. 
```{r cars, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth()

ggplot() + 
  geom_point(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_smooth(data = mpg, mapping = aes(x = displ, y = hwy))
```

### 6. Recreate the R code necessary to generate the following graphs.

```{r cars, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth(se = FALSE)
```

```{r cars, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point() + 
  geom_smooth(se = FALSE)
```

```{r cars, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy, color = drv)) + 
  geom_point() + 
  geom_smooth(se = FALSE)
```

```{r cars, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = drv)) + 
    geom_smooth(se = FALSE, show.legend = FALSE)
```

```{r cars, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(color = drv)) +
  geom_smooth(mapping = aes(linetype = drv), se = FALSE)
```

```{r cars, echo=TRUE}
ggplot(data = mpg, mapping = aes(x = displ, y = hwy)) + 
  geom_point(mapping = aes(fill = drv), shape = 21, stroke = 2, color = "white", size = 3)
```


## Intro


## Facets
This is placeholder for answers to facet questions
```{r facets, echo=TRUE, include=TRUE}
 ggplot(data = mpg) + 
    geom_point(mapping = aes(x = displ, y = hwy)) +
   
    facet_grid(drv ~ cyl)

 ggplot(data = mpg) + 
    geom_point(mapping = aes(x = displ, y = hwy)) +
    facet_wrap(. ~ class, nrow=3)

```

## Geoms

## Stats

### Question 1.
What is the default geom associated with `stat_summary()`? How could you rewrite the previous plot to use that geom function instead of the stat function?

First, the original plot.
```{r}
ggplot(data = diamonds) + 
  stat_summary(
    mapping = aes(x = cut, y = depth),
    fun.min = min,
    fun.max = max,
    fun = median
  )
```

The default geom associated with `stat_summary()` is `geom_pointrange()`. To recreate the previous plot using `geom_pointrange()` we can summarize the relevant information before plotting. 
```{r}
d <- diamonds %>% 
  group_by(cut) %>% 
  summarise(min = min(depth), max = max(depth), median = median(depth))

ggplot(data = d) +
  geom_pointrange(aes(x = cut, y = median, ymin = min, ymax = max))
```

### Question 2.
What does `geom_col()` do? How is it different to `geom_bar()`?

`geom_col` differs from `geom_bar` in the default stat transformation that it uses. `geom_bar` uses `stat_count` by default, so you can create a bar chart without grouping observations and finding the total number in each group, `stat_count` will do it for you. If, for some reason, you have data which are already grouped so that the total number in each group (the height of each bar) is a column in the data frame, you can use `geom_col` since its default stat transformation is `stat_identity`, which leaves data as is. 

### Question 3.
Most geoms and stats come in pairs that are almost always used in concert. Read through the documentation and make a list of all the pairs. What do they have in common?


| geom                | stat                |
|---------------------|---------------------|
| `geom_bar()`        | `stat_count()`      |
| `geom_bin2d()`      | `stat_bin_2d()`     |
| `geom_boxplot()`    | `stat_boxplot()`    |
| `geom_contour()`    | `stat_contour()`    |
| `geom_count()`      | `stat_sum()`        |
| `geom_density()`    | `stat_density()`    |
| `geom_density_2d()` | `stat_density_2d()` |
| `geom_hex()`        | `stat_hex()`        |
| `geom_freqpoly()`   | `stat_bin()`        |
| `geom_histogram()`  | `stat_bin()`        |
| `geom_qq_line()`    | `stat_qq_line()`    |
| `geom_qq()`         | `stat_qq()`         |
| `geom_quantile()`   | `stat_quantile()`   |
| `geom_smooth()`     | `stat_smooth()`     |
| `geom_violin()`     | `stat_violin()`     |
| `geom_sf()`         | `stat_sf()`         |

These geom and stat pairs are almost always used together. Generally, corresponding geom-stat pairs will have matching names, although there are a few exceptions.

### Question 4.
What variables does `stat_smooth()` compute? What parameters control its behaviour?

`stat_smooth` calculates a predicted y value, upper and lower bounds of a confidence interval, and standard error. The two most important arguments for controlling the behavior of stat_smooth are `method` and `formula`. The former establishes which statistical method you would like to use to find predictions (e.g. `lm`, `loess`, or `gam`), and the latter specifies the formula.


### Question 5. 
In our proportion bar chart, we need to set group = 1. Why? In other words what is the problem with these two graphs?

```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, y = ..prop..))
```

By default, `geom_bar()` groups according to the grouping variable assigned to `x` in the aesthetic mapping. So when you try to calculate proportions, it will consider each group as a whole. This gives every group a proportion of 1. To specify that you want proportions calculated using the grand total, you need to consider all the groups as one big group by setting `group = 1`. 

## Positioning



## Coordinate Systems

Coordinate systems provide the ability to specify any given point in a plot. The most commonly known is Cartesian, which is just the standard X,Y format we are all used to. Each X and pair points to a specific place on the chart. But there are other features in R that can also be used to specify location in more complex ways.

--coord_flip() swaps the X and Y axes.
--coord_quickmap() used for special mapping in plots, for example on a map of Oregon.
--coord_polar() 

#### Coordinate Systems exercises
1. Create a polar plot: see below
2. What does labs() do? It allows adding titles, subtitles, captions, tags, and labels to the charts. Title was added to the charts below this way.
3. What is the difference between coord_map and coord_quickmap? Coord_map attempts to represent geography on a spherical plane, whereas coord_quickmap assumes the plane is flat. Coord_quickmap is best for smaller geographical areas where distortion won't cause problems with the data representation.
4. What does this plot tell you about the relationship between city and highway mpg? Higher city mileage is associated with higher highway mileage, but as hwy mileage goes up, there is a slight lag in city mileage increase ( the overall slope of the data seems to tilt left of the neutral line)
---What is geom_abline? this puts a line of a particular slope on the graph. By default it puts a 1x1 slope on the graph.
---What is coord_fixed? This enforces an "aspect ratio" so that the scales on the x and y axes are fixed in a ratio. 

```{r coordinate systems echo=TRUE, include=TRUE}

# Playing with bar and polar charts
bar <- ggplot(data = mtcars) +
  geom_bar(
    mapping = aes(x=cyl, fill=cyl),
    show.legend = FALSE,
    width = 1
  ) +
  theme(aspect.ratio = 1) 

bar + coord_flip() + labs(title = "No of Models by Cylinders")
bar + coord_polar() + labs(title = "No of Models by Cylinders ")
bar + labs(title="No of Models by Cylinders")

# Trying out abline and fixed

ggplot(data=mpg, mapping = aes(x = cty, y=hwy)) +
  geom_point() +
  geom_abline() +
  coord_fixed()
  
```
## 3.8 Position Adjustments   
   
You can color a bar chart using either the <colour> or <fill> aesthetic:   
   
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, colour = cut))
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = cut))
```   
   
Mapping the fill aesthetic to a different variable stacks the bars:   
   
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity))
```   
   
Stacking is performed automatically by the **position adjustment** specificed by the <position> argument. Other options for *position adjustment* are <"identity">, <"dodge">, or <"fill">.   
   
<position = "identity"> will place each object exactly where it falls in the context of the graph (overlaps the bars, so we need to use <alpha> or <fill = NA> to see them).   
   
```{r}
ggplot(data = diamonds, mapping = aes(x = cut, fill = clarity)) + 
  geom_bar(alpha = 1/5, position = "identity")
ggplot(data = diamonds, mapping = aes(x = cut, colour = clarity)) + 
  geom_bar(fill = NA, position = "identity")
```   
   
<position = "fill"> makes each set of stacked bars the same height, for proportion comparison.   
   
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "fill")
```   
   
<position = "dodge"> places overlapping objects directly *beside* one another.   
   
```{r}
ggplot(data = diamonds) + 
  geom_bar(mapping = aes(x = cut, fill = clarity), position = "dodge")
```   
   
**overplotting**: many points overlapping on the grid and make it hard to see where the mass of the data is.   
   
Setting <position = "jitter"> fixes this by adding a small amount of random noise to each point.   
   
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x = displ, y = hwy), position = "jitter")
```   
   
ggplot2 has a shorthand for <geom_point(position = "jitter")>: <geom_jitter()>.   
   
Other position adjustments: <position_dodge>, <position_fill>, <position_identity>, <position_jitter>, and <position_stack> (look up using ? in R for more info).   
  
### 3.8.1 Exercises   
   
1) What is the problem with this plot? How could you improve it?   
   
```{r}
ggplot(data = mpg, mapping = aes(x = cty, y = hwy)) + 
  geom_point()
```   
   
The problem with this plot is that it doesn't show all the points, so we are unable to tell where the concentration of observations lie. We can fix this by setting <position = "jitter"> to add a small amount of random noise:   
   
```{r}
ggplot(data = mpg) + 
  geom_point(mapping = aes(x=cty, y=hwy), position = "jitter")
```   
   
2) What parameters to <geom_jitter()> control the amount of jittering?   
   
```{r}
?geom_jitter()
```   
   
<width> and <height> control the amount of horizontal and vertical jitter added in both positive and negative directions. These default to 40% of the resolution of the data (doubled by being both in positive and negative directions so that jitter values are 80% of the bins).   
   
3) Compare and contrast <geom_jitter()> with <geom_count()>.   
   
```{r}
?geom_count()
```   
   
Both <geom_jitter()> and <geom_count()> serve the purpose of better displaying many many data points that may otherwise be obscured by binning and consolidation in the plotting defaults. While <geom_jitter> adds a small bit of random noise to move each of the points into view, <geom_count()> "counts the number of observations at each location, then maps the count to point area" so that the viewer can percieve the volume of points in a certain area based on the size of the point shown.   
   
4) What's the default position adjustment for <geom_boxplot()>? Create a visualization of the <mpg> dataset that demonstrates it.   
   
```{r}
?geom_boxplot()
```   
   
The default position adjustment seems to be some level of dodging, at least enough that the boxes do not overlap. There is no natural order to the categorical <trans> variable, so I used it and <hwy> in the following example to show how <geom_boxplot()> dodges the categories:   
   
```{r}
ggplot(data = mpg) + 
  geom_boxplot(mapping = aes(trans,hwy))
```   
   

